"""This file contains all the tools that can be used by the models."""

import ast
import re
import subprocess
import sys
import time
from typing import Callable, Dict, Sequence, Union

import enchant
import openai
from pot_tools import safe_execute, simplify_ans
import requests
from serpapi import GoogleSearch
from utils import OpenAIModel, cleanhtml
import pickle
from os import path

Tool = Callable[[str, str, str], tuple(str, str)]
"""Tools are functions with two inputs:

- (str) the command input
- (str) the previous command's output

The output is a tuple of two strings:

- (str) the output
- (str) runtime details to be logged
"""

OUTPUT_DIRECTORY = "./kvstore"


def get_run_dict(run_title, output_directory=OUTPUT_DIRECTORY):
    try:
        with open(path.join(output_directory, run_title + ".pickle"), "rb") as handle:
            run_dict = pickle.load(handle)
    except FileNotFoundError:
        run_dict = {}
        print("creating a new dict for run: ", run_title)
        return run_dict


def save_run_dict(run_dict, run_title, output_directory=OUTPUT_DIRECTORY):
    with open(path.join(output_directory, run_title + ".pickle"), "wb") as handle:
        pickle.dump(run_dict, handle, protocol=pickle.HIGHEST_PROTOCOL)
    return


def read(key, _, run_title) -> tuple(str, str):
    read_write_dict = get_run_dict(run_title)
    if key in read_write_dict:
        return read_write_dict[key], None
    # TODO finalize key not found behaviour
    # else:
    #     return ', '.join(read_write_dict.keys()), None
    return f"<key '{key}' did not exist>", None  # TODO: return a useful log message


def list_keys(_, __, run_title):
    read_write_dict = get_run_dict(run_title)
    return ", ".join(read_write_dict.keys())


def parse_instruction(instruction):
    # parse `instruction` = (first day creation) God created the earth, light, and dark.
    split = instruction.split(")", 1)
    key = split[0][1:]  # remove "("
    text = split[1].strip()
    return key, text


def write(instruction, _, run_title="") -> tuple(str, str):
    """
    key = first day creation
    text = God created the earth, light, and dark.
    """
    key, text = parse_instruction(instruction)

    read_write_dict = get_run_dict(run_title)
    read_write_dict[key] = text
    save_run_dict(read_write_dict, run_title)

    return "", None  # TODO: return a useful log message


def arithmetic(equations: str, _, __) -> tuple(str, str):
    # collect all outputs of arithmetic and run python to execute them
    # TODO this makes no sense
    result = subprocess.run(
        [sys.executable, "-c", "\n".join(equations)], capture_output=True, text=True
    )
    return result, None


def code_edit(instruction: str, code_input: str, _) -> tuple(str, str):
    """Edit some code according to the instruction."""
    comment = "# " + instruction + "\n"
    response = openai.Completion.create(
        # model="code-davinci-002",
        model="davinci-codex-002-msft",
        prompt=comment,
        temperature=0.0,
        max_tokens=256,
        top_p=1,
        frequency_penalty=0,
        presence_penalty=0,
        stop=["\n"],
    )

    code_snippet = response.choices[0].text
    return comment + code_snippet, comment


def code_execute(code_snippet: str, code_input: str = None, _="") -> tuple(str, str):
    if code_input:
        try:
            # Run arithmetic python code generate
            code_output = safe_execute(code_input)
            result = simplify_ans(code_output)
            if result:
                return result, code_input
        except:
            pass

    try:
        # Run code snippet as is, if it was generated by code_generate
        # More robust outputs
        result = subprocess.run(
            [sys.executable, "-c", code_input],
            capture_output=True,
            text=True,
            timeout=60,
        )
        if result.stderr == "":
            simplified_result = simplify_ans(result.stdout)
            return simplified_result, code_snippet
    except:
        pass

    try:
        # Run arithmetic python code generate
        code_output = safe_execute(code_snippet)
        result = simplify_ans(code_output)
        if result:
            return result, code_snippet
    except:
        pass

    try:
        # Run code snippet as is, if it was generated by code_generate
        result = subprocess.run(
            [sys.executable, "-c", code_snippet],
            capture_output=True,
            text=True,
            timeout=60,
        )
        if result.stderr == "":
            simplified_result = simplify_ans(result.stdout)
            return simplified_result, code_snippet
    except:
        pass

    if "error" in code_snippet or (code_input and "error" in code_input):
        return code_error(code_snippet, code_input)

    try:
        # Command instruction (if its code) starts in the next line.
        code_snippet = code_snippet.split("\n", 1)[1]
        result = subprocess.run(
            [sys.executable, "-c", code_snippet],
            capture_output=True,
            text=True,
            timeout=60,
        )
        if result.stderr == "":
            simplified_result = simplify_ans(result.stdout)
            return simplified_result, code_snippet
    except:
        return None, code_snippet

    return None, code_snippet


def code_generate(instruction: str, code_input: str, _) -> tuple(str, str):
    # response = openai.Edit.create(
    # model="code-davinci-edit-001",
    # input="x = " + code_input,
    # instruction="Python code for " + instruction,
    # temperature=0,
    # top_p=1
    # )
    if instruction in code_input:
        # Code input is sufficient to write code
        comment = '"""\n{0}\nStore the final result as a variable named \'ans\' and print it.\n"""\n\n'.format(
            code_input
        )
    else:
        if re.search("#[0-9]+", instruction):
            input_string = re.search("#[0-9]+", instruction).group(0)
            instruction = instruction.replace(input_string, "Input")
        # comment = "\"\"\"\n{0}\nInput:{1}\nStore the final result as a variable named 'ans' and print it.\n\"\"\"\n\ndef".format(instruction, code_input)
        comment = '"""\n{0}\nInput:{1}\nStore the final result as a variable named \'ans\' and print it.\n"""\n\n'.format(
            instruction, code_input
        )

    response = openai.Completion.create(
        # model="code-davinci-002",
        model="davinci-codex-002-msft",
        prompt=comment,
        temperature=0.0,
        max_tokens=256,
        top_p=1,
        frequency_penalty=0,
        presence_penalty=0,
        stop=["print(ans)"],
    )

    code_snippet = response.choices[0].text
    time.sleep(5)

    # TODO: Add function run or remove the "def" entirely
    # return "def" + code_snippet, comment
    # if "ans" in code_snippet:
    #     code_snippet += "\nprint(ans)"

    # TODO: Add "print(ans) to the end."
    return code_snippet, comment


_gpt3 = OpenAIModel(model="text-davinci-002", max_length=200, quote="", n=1)


def generate(prompt: str, _, __) -> tuple(str, str):
    """Generate a completion using 'text-davinci-002'."""
    return _gpt3(prompt)[0], None


_search_bing_url = "https://api.bing.microsoft.com/v7.0/search"
_search_bing_headers = {"Ocp-Apim-Subscription-Key": "28dc412935f24fb9974d80c30915483a"}


def search_bing(query: str, _, __, top_k=1) -> tuple(str, str):
    # get results
    params = {"q": query, "textDecorations": True, "textFormat": "HTML"}
    response = requests.get(_search_bing_url, headers=_search_bing_headers, params=params)
    response.raise_for_status()
    search_results = response.json()

    # parse results
    if "webPages" not in search_results:
        return "", None

    snippets = []
    for v in search_results["webPages"]["value"][:top_k]:
        snippets.append(cleanhtml(v["name"] + " " + v["snippet"]))

    return "\n".join(snippets), None


_serp_api_key = "5599fad2263e4b1c6d4efb62fa15f83f5ad2d1bb727b8721d616d719399a7f7b"


def search_google(query: str, _, __) -> tuple(str, str):
    params = {
        "q": query,
        "hl": "en",
        "gl": "us",
        "google_domain": "google.com",
        "api_key": _serp_api_key,
    }

    search = GoogleSearch(params)
    try:
        res = search.get_dict()
    except requests.HTTPError as e:
        print("HTTP error while using SerpAPI:", str(e))
        res = {}

    if "answer_box" in res and "answer" in res["answer_box"]:
        toret = res["answer_box"]["answer"]
    elif "answer_box" in res and "snippet" in res["answer_box"]:
        toret = res["answer_box"]["snippet"]
    elif "answer_box" in res and "snippet_highlighted_words" in res["answer_box"]:
        toret = res["answer_box"]["snippet_highlighted_words"][0]
    elif "organic_results" in res and "snippet" in res["organic_results"][0]:
        toret = res["organic_results"][0]["snippet"]
    else:
        toret = None

    return toret, None


def code_generate_then_execute(instruction: str, code_input: str, _) -> tuple(str, str):
    # output = openai.Edit.create(
    # model="code-davinci-edit-001",
    # input="x = " + code_input,
    # instruction="Python code for " + instruction,
    # temperature=0,
    # top_p=1
    # )
    # code_snippet = output.choices[0].text

    code_snippet, generate_details = code_generate(instruction=instruction, code_input=code_input)
    time.sleep(2)
    # result = subprocess.run([sys.executable, "-c", code_snippet], capture_output=True, text=True)
    # if result.stderr == "":
    #     return result.stdout, code_snippet
    result = code_execute(code_snippet=code_snippet)
    return result


def code_error(code_snippet: str, code_input: str, _) -> tuple(str, str):
    # Command instruction (if its code) starts in the next line.
    try:
        code_snippet = code_snippet.split("\n", 1)[1]
        result = subprocess.run(
            [sys.executable, "-c", code_snippet],
            capture_output=True,
            text=True,
            timeout=60,
        )
        if result.stderr != "":
            return result.stderr, code_snippet
    except:
        return None, code_snippet


def code_generate_then_lookup(instruction: str, code_input: str, _) -> tuple(str, str):
    code_snippet, generate_details = code_generate(instruction=instruction, code_input=code_input)
    time.sleep(2)
    result, execute_snippet = code_execute(code_snippet=code_snippet)
    d = enchant.Dict("en_US")
    try:
        word_list = ["".join(chat_list) for chat_list in ast.literal_eval(result)]
        valid_list = []
        for word in word_list:
            if d.check(word):
                valid_list.append(word)
        return simplify_ans(valid_list), execute_snippet
    except:
        return None, execute_snippet


def lookup(word_list):
    d = enchant.Dict("en_US")
    valid_list = []
    for word in word_list:
        if d.check(word):
            valid_list.append(word)
    return valid_list


tool_dict: Dict[str, Tool] = {
    "[arithmetic]": arithmetic,
    "[code edit]": code_edit,
    "[code execute]": code_execute,
    "[code generate]": code_generate,
    "[generate]": generate,
    "[search]": search_google,
    "[string edit]": code_generate_then_execute,
    "[string index]": code_generate_then_execute,
    "[string permutation]": code_generate_then_lookup,
    "[read]": read,
    "[write]": write,
    "[list keys]": list_keys,
}


keyword_map = {
    "[execute]": "[code execute]",
    "[generate python code]": "[code generate]",
    "[permutation]": "[string permutation]",
    "[permute]": "[string permutation]",
    "[string permute]": "[string permutation]",
}


for keyword in keyword_map:
    assert keyword not in tool_dict, "a keyword exists that's already in the tool_dict"


def get_tool(name: str, exclude: Sequence[str]) -> Union[Tool, None]:
    """Get a Tool from tool_dict by exact name, or an alias in keyword_map.

    Returns None if not found."""
    if name in exclude:
        return None
    if name in tool_dict:
        return tool_dict[name]
    if name in keyword_map:
        name = keyword_map[name]
        if name in exclude:
            return None
        return tool_dict[name]

    return None
